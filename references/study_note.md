# 第十章：查询处理（slide10）
首先，这篇文章的核心就在于：**解析，优化，查询**。
## 解析
解析指的是将SQL语句解析成不同的步骤，接下来会去挨个执行不同的步骤。解析一共有三个解析过程，分别为：**词法分析，语法分析，语义分析**。
接下来，我们以一个例子来解释三个分析过程：
首先，我们通过SQL语句可以生成两张表格：
```sql
-- 创建Student表（学生表）
CREATE TABLE Student (
    Sno VARCHAR(10) PRIMARY KEY,  -- 学号，主键，长度为10的可变字符串
    Sname VARCHAR(20),            -- 学生姓名，长度为20的可变字符串
    Sgender VARCHAR(2),           -- 学生性别，长度为2的可变字符串（如"男"、"女"）
    Sage INT,                     -- 学生年龄，整型数据
    Sdept VARCHAR(20)             -- 学生所属系，长度为20的可变字符串（如"CS"表示计算机系）
);

-- 创建SC表（学生选课表）
CREATE TABLE SC (
    Sno VARCHAR(10),              -- 学号，外键，对应Student表的Sno
    Cno VARCHAR(10),              -- 课程号，长度为10的可变字符串
    Grade INT,                    -- 成绩，整型数据
    PRIMARY KEY (Sno, Cno)        -- 联合主键，由学号和课程号组成
);

-- 插入学生数据
INSERT INTO Student (Sno, Sname, Sgender, Sage, Sdept) VALUES
('2021310721', '李博', '男', 17, 'CS'),  -- 计算机系学生李博
('2021310722', '赵宇', '男', 19, 'CS'),  -- 计算机系学生赵宇
('2021310723', '王倩', '女', 18, 'MA'),  -- 数学系学生王倩
('2021310724', '孙悦', '女', 20, 'IS');  -- 信息系学生孙悦

-- 插入选课及成绩数据
INSERT INTO SC (Sno, Cno, Grade) VALUES
('2021310721', '5', 98),  -- 李博选修5号课程，成绩98分
('2021310722', '1', 87),  -- 赵宇选修1号课程，成绩87分
('2021310723', '1', 92),  -- 王倩选修1号课程，成绩92分
('2021310721', '1', 85);  -- 李博选修1号课程，成绩85分
```
运行语句：
```sql
SELECT S.Sname, SC.Grade   -- 选择学生姓名和成绩两个字段
FROM   Student AS S        -- 从Student表（别名为S）中查询
    JOIN SC ON S.Sno = SC.Sno  -- 与SC表进行内连接，连接条件是学号相同，join表示内连接。
WHERE  S.Sdept = 'CS'      -- 筛选条件1：只选计算机系(CS)学生
    AND SC.Grade >= 90; -- 筛选条件2：只选成绩大于等于90分的记录
```

```
如果有三张或者三张以上的表格，join的用法如下：
SELECT S.Sname, C.Cname, SC.Grade
FROM Student AS S
JOIN SC ON S.Sno = SC.Sno
JOIN Course AS C ON SC.Cno = C.Cno
WHERE S.Sdept = 'CS' AND SC.Grade >= 90;
这样一层层连接起来，就可以将表格进行内联。
FROM A
JOIN B ON 条件1
JOIN C ON 条件2
JOIN D ON 条件3
...
在很多张表格组合起来之后，每一张表格的主键也可以连接起来，成为逻辑主键


```

### 词法分析
方法：按照SQL词法将文本拆成token并且标注类别：**关键词、标识符、常量、运算符，分隔符，注释**
在上述代码中，我们可以将SQL语句进行处理，得到所有最小，有明确标识的记号（token）。六大类型分别有如下保留字：
#### 1，关键字（SQL本身自带的字）：
```sql
SELECT, FROM, WHERE, JOIN, ON, AS, GROUP, BY, ORDER, HAVING,
INSERT, INTO, VALUES, UPDATE, SET, DELETE,
CREATE, TABLE, PRIMARY, KEY, FOREIGN, NOT, NULL, AND, OR, IN, IS, LIKE, DISTINCT, EXISTS
```


#### 2，标识符（用户定义的名字，用来标识表、列、别名、数据库、索引等对象）：
```sql
在本表格中，标识符为：
Student, SC，Sno, Sname, Sgender, Sage, Sdept，Cno, Grade
```
这些字段都是用户进行定义的。

#### 3，常量（用户写在表格中的内容，也就是表格中的具体值）：
```sql
在本代码中，以下内容都是常量：
INSERT INTO Student (Sno, Sname, Sgender, Sage, Sdept) VALUES
('2021310721', '李博', '男', 17, 'CS'),  -- 常量：学号、姓名、性别、年龄、系别
('2021310722', '赵宇', '男', 19, 'CS'),  -- 常量：学号、姓名、性别、年龄、系别
('2021310723', '王倩', '女', 18, 'MA'),  -- 常量：学号、姓名、性别、年龄、系别
('2021310724', '孙悦', '女', 20, 'IS');  -- 常量：学号、姓名、性别、年龄、系别
```

#### 4，运算符（用于表达计算，条件，连接等操作的符号）
```sql
系统决定：
=, <>, <, <=, >, >=,
+, -, *, /,
AND, OR, NOT,
LIKE, IN, IS, BETWEEN
```

#### 5，分隔符（分割字段和语句）：
```sql
,    -- 逗号：用于分隔列名或值
;    -- 分号：结束一条 SQL 语句
( )  -- 括号：用于分组、函数参数、子查询
.    -- 点号：表.列 的限定
```


#### 6，注释（就是简单的注释）：
```sql
单行注释：-- 注释内容
多行注释：/* 注释内容 */
```
词法分析就可以将上述六个内容识别出来，例如在上述代码中，可以拆解成为：
```sql
-- 词法分析结果
[关键词]     SELECT
[标识符]     S.Sname
[符号]       ,
[标识符]     SC.Grade
[关键词]     FROM
[标识符]     Student
[关键词]     AS
[标识符]     S
[关键词]     JOIN
[标识符]     SC
[关键词]     ON
[标识符]     S.Sno
[符号]       =
[标识符]     SC.Sno
[关键词]     WHERE
[标识符]     S.Sdept
[符号]       =
[常量]       'CS'
[关键词]     AND
[标识符]     SC.Grade
[符号]       >=
[常量]       90
[符号]       ;

-- 注释（非执行部分）
[注释]       -- 选择学生姓名和成绩两个字段
[注释]       -- 从Student表（别名为S）中查询
[注释]       -- 与SC表进行内连接，连接条件是学号相同
[注释]       -- 筛选条件1：只选计算机系(CS)学生
[注释]       -- 筛选条件2：只选成绩大于等于90分的记录

-- 空白符（省略显示，存在于词法单位之间）
```
### 语法分析
语法分析相当于将拆分出来的不同的词串装组成抽象语法树：
首先先拆分字符：
```sql
[SELECT], [ID:S.Sname], [,], [ID:SC.Grade],
[FROM], [ID:Student], [AS], [ID:S],
[JOIN], [ID:SC], [ON], [ID:S.Sno], [=], [ID:SC.Sno],
[WHERE], [ID:S.Sdept], [=], [STR:'CS'],
[AND], [ID:SC.Grade], [>=], [NUM:90]
```
然后串起来构成语法树：
```
<query>
├── SELECT
│   └── <select_list>
│       ├── S.Sname
│       └── SC.Grade
├── FROM
│   └── <table_expr>
│       ├── <table_ref>
│       │   ├── Student
│       │   └── AS S
│       ├── JOIN
│       ├── <table_ref>
│       │   └── SC
│       └── ON
│           └── <condition>
│               └── S.Sno = SC.Sno
└── WHERE
    └── <condition>
        ├── S.Sdept = 'CS'
        └── AND
        └── SC.Grade >= 90

```


上述代码表示两个表格的拼接，可以用一个连接算子来表示：

**Student ⨝_{Sno} SC（表示二者相连接）**
```sql
+-------------+--------+---------+------+--------+-----+-------+
| Sno         | Sname  | Sgender | Sage | Sdept  | Cno | Grade |
+-------------+--------+---------+------+--------+-----+-------+
| 2021310721  | 李博   | 男      | 17   | CS     | 5   | 98    |
| 2021310721  | 李博   | 男      | 17   | CS     | 1   | 85    |
| 2021310722  | 赵宇   | 男      | 19   | CS     | 1   | 87    |
| 2021310723  | 王倩   | 女      | 18   | MA     | 1   | 92    |
+-------------+--------+---------+------+--------+-----+-------+
```
**注意：连接算子满足交换律和结合律，也满足选择分配律和投影分配律。**
至此，我们就学习了第一个算子：连接算子⨝。
### 语义分析
通俗来讲，就是上文所说的，将其进行连接：
```sql
-- 语义分析成功后的关系代数查询树表示：
π_{Sname, Grade}  
  σ_{Sdept = 'CS' ∧ Grade ≥ 90}  
    ⨝_{Student.Sno = SC.Sno}  
      Student  
      SC

```
这样，我们就可以将数据库进行一个初步的整理，目的是得到了一个可以运行的查询树，可以理解成一个粗整理。

顺其自然的，我们就得了解这些相关的算子，有哪些算子呢？

### 所有算子：
| 类别       | 算子        | 说明                                                     |
|------------|-------------|----------------------------------------------------------|
| 投影       | π（pi）      | 从结果中选取指定属性列                                  |
| 选择       | σ（sigma）   | 按条件筛选元组，如 σ_{Grade ≥ 90}(SC)                    |
| 连接       | ⨝（join）    | 将多个关系按条件组合，如 R ⨝_{A=B} S                    |
| 自然连接   | ⨝（自然连接）| 自动按同名属性连接                                       |
| 笛卡尔积   | ×           | 所有元组组合，常用于无连接条件情况                       |
| 并         | ∪           | 合并两个关系中的所有元组                                 |
| 差         | −           | 两个关系中属于第一个但不属于第二个的元组                 |
| 交         | ∩           | 两个关系中都包含的元组                                   |
| 去重       | δ（delta）   | 消除重复元组                                             |
| 分组聚集   | γ（gamma）   | GROUP BY + 聚集函数（SUM、AVG 等）                       |
| 排序算子   | Sort        | 外部归并排序，代价为 2 * ⌈log_{M-1}(B/M)⌉               |
| 选择算子   | IndexScan   | 用索引定位元组，聚簇与非聚簇的代价不同                   |
|            | TableScan   | 全表扫描                                                 |
| 连接算子   | NLJ         | 嵌套循环连接（Nested Loop Join）                        |
|            | BNLJ        | 块嵌套循环连接（Block Nested Loop Join）                 |
|            | INLJ        | 索引嵌套循环连接（Index Nested Loop Join）               |
|            | SMJ         | 排序-归并连接（Sort-Merge Join）                         |
|            | HashJoin    | 哈希连接，构建哈希表后进行匹配                           |
| 去重/集合  | Sort/Hash   | 基于排序或哈希实现集合运算（∪ ∩ −）和去重（δ）           |


算子顺序：

| 步骤 | 对应算子             | 说明                      |
| -- | ---------------- | ----------------------- |
| ①  | **FROM / JOIN**  | 连接各个表，形成临时笛卡尔积或连接结果     |
| ②  | **WHERE**        | 对上述结果做选择（σ），剔除不满足条件的行   |
| ③  | **GROUP BY**     | 对剩下的行分组，逻辑上进入 γ（分组聚合）算子 |
| ④  | **HAVING**       | 对每组做筛选，类似 GROUP 之后的 σ   |
| ⑤  | **SELECT**       | 投影（π），提取所需字段和聚合结果       |
| ⑥  | **DISTINCT**（可选） | 去重（δ），如 SELECT DISTINCT |
| ⑦  | **ORDER BY**     | 排序（Sort）                |

算子优先级：

| 优先级 | 算子类别     | 说明                          |
| --- | -------- | --------------------------- |
| 高   | 选择（σ）    | 越早筛掉不必要的行越节省计算资源            |
| 高   | 投影（π）    | 只保留需要的列，也有助于减少后续 I/O        |
| 中   | 连接（⨝）    | 是组合多个表的核心操作，代价较高，顺序优化很关键    |
| 中   | 分组聚合（γ）  | 只有在投影和连接之后才有意义              |
| 中   | 去重（δ）    | 通常是 SELECT DISTINCT 或集合运算触发 |
| 低   | 排序（Sort） | 排序通常最后执行，对结果进行排列            |

上述语句用算子表示可以表示成如下形式：
$$
\pi_{Sname,Grade} \left( (\sigma_{Sdept='CS'}(Student)) \underset{Student.Sno=SC.Sno}{\bowtie} (\sigma_{Grade \ge 90}(SC)) \right)
$$
*所以，如果定义计算这个函数的时间最短，即为优化函数。（这啥屁话）*

## 逻辑优化与物理优化
在学习这部分内容之前，先将这两个表格进行可视化操作：
**Student表（学生表）**
| Sno        | Sname | Sgender | Sage | Sdept |
| :--------- | :---- | :------ | :--- | :---- |
| 2021310721 | 李博  | 男      | 17   | CS    |
| 2021310722 | 赵宇  | 男      | 19   | CS    |
| 2021310723 | 王倩  | 女      | 18   | MA    |
| 2021310724 | 孙悦  | 女      | 20   | IS    |

**SC表（学生选课表）**
| Sno        | Cno | Grade |
| :--------- | :-- | :---- |
| 2021310721 | 5   | 98    |
| 2021310722 | 1   | 87    |
| 2021310723 | 1   | 92    |
| 2021310721 | 1   | 85    |

我们的查询语句为：
```sql
SELECT Sname, Grade
FROM SC, Student
WHERE SC.Sno = Student.Sno AND Cno = '1';
```
## 代价估计
优化，得有一个评价标准，然后朝着这个评价标准更好的方向进行优化。
这个评价标准，就叫做代价。所以，我们要先学会计算代价：
在计算过程中，会有三种代价：
1，磁盘I/O代价（Disk I/O Cost）
**通俗来讲，磁盘代价就是读取数据的量。**比如上述两张表格，一共有8行数据，所以磁盘代价就是**8**。
2，CPU代价（CPU Cost）
**可以理解成计算过程中数据库执行查询的时候，中央处理器消耗的计算资源。**比如在连接上述两张表格的时候，要对每一个Sno值进行如下计算：
（1，1）对（2，1），（2，2），（2，3），（2，4）进行四次匹配，找到相同的。
（2，1）对（2，1），（2，2），（2，3），（2，4）进行四次匹配，找到相同的。
（3，1）对（2，1），（2，2），（2，3），（2，4）进行四次匹配，找到相同的。
（4，1）对（2，1），（2，2），（2，3），（2，4）进行四次匹配，找到相同的。
其中，（a，b）表示第a张表格第b个sno数值。
所以CPU COST就是16
3，内存代价（Memory Cost）
表示中间过程如果运算量很大，需要类似缓存的操作，就要写入内存，就是内存代价。
假设你要查询一个很大的 Student 表，并按学生的年龄进行排序。如果表的数据可以完全装入内存（比如表中有 1000 条记录，每条记录占 1KB 的内存），那排序的操作可以直接在内存中完成，不需要访问磁盘，这样内存代价相对较低。

但如果 Student 表的数据很大，无法完全装入内存（比如有 10 万条记录），那么数据库需要分批处理这些数据，这时它可能需要用磁盘来存储中间的排序结果，这就增加了磁盘I/O代价，也增加了内存的消耗（因为数据库可能需要用内存来管理这些中间数据）。

### 计算过程中给的一些小技巧
#### SQL语句以及两张表格
```sql
SELECT Sname, Grade
FROM SC, Student
WHERE SC.Sno = Student.Sno AND Cno = '1';
```
**Student表（学生表）**
| Sno        | Sname | Sgender | Sage | Sdept |
| :--------- | :---- | :------ | :--- | :---- |
| 2021310721 | 李博  | 男      | 17   | CS    |
| 2021310722 | 赵宇  | 男      | 19   | CS    |
| 2021310723 | 王倩  | 女      | 18   | MA    |
| 2021310724 | 孙悦  | 女      | 20   | IS    |

**SC表（学生选课表）**
| Sno        | Cno | Grade |
| :--------- | :-- | :---- |
| 2021310721 | 5   | 98    |
| 2021310722 | 1   | 87    |
| 2021310723 | 1   | 92    |
| 2021310721 | 1   | 85    |
首先，我们有一些基本概念：
### 1，基数（实际结果数量）
搜索结果实际有多少，基数就是多少。在这个表格中，基数就是3
### 2，选择度（估算得到）
$$选择度 = \frac{\text{满足条件的记录数}}{\text{表中总记录数}} = \frac{3}{4} = 0.75$$
数据库首先扫描 SC 表，筛选出 Cno = '1' 的记录。SC 表有 4 条记录，因此扫描的磁盘I/O代价是 4 个块。
### 3，基数估计（优化器估计结果数量）
总记录=4条，选择度是0.75，所以基数也是3

### 4，代价计算
先说结论：
首先，我们将代价拆分成三个代价：
$$Cost_{I/O}:磁盘I/O代价$$
$$\mathrm{Cost_{CPU}:~CPU计算代价}$$
$$Cost_Mem:内存占用代价$$
我们可以计算总代价函数为：
$$\mathrm{Cost_{Total}}=\cdot\mathrm{Cost_{I/O}}+\beta\cdot\mathrm{Cost_{CPU}}+\gamma\cdot\mathrm{Cost_{Mem}}$$
其中，$\alpha,\beta,\gamma$表示系统定义的权重参数。


具体的代价计算：
#### I/O代价计算
**假设我们有$n$张表格，分别记为：$R_{1},R_{2},\ldots,R_{n}$，每张表都有若干选择条件、连接操作。**
**$$\mathrm{Cost}_{\mathrm{I/O}}=\sum_{i=1}^n\mathrm{I/O}_{\mathrm{select}}(R_i)+\sum_{j=1}^m\mathrm{I/O}_{\mathrm{join}}^{(j)}(R_j,S_j)$$


---
其中
**$\sum_{i=1}^n\mathrm{I/O}_{\mathrm{select}}(R_i)$表示扫描+选择的I/O代价**
<font size = 2 color = red>

如果没有索引，$\mathrm{I/O}_{\mathrm{select}}(R_i)=T(R_i)$，$T(R_i)$表示表$R_i$的总记录数。在上述例子中，总记录数是4。（只考虑行数）
如果已有索引，$\mathrm{I/O}_{\mathrm{select}}(R_i)=\mathrm{sel}(R_i)\cdot\log_B(T(R_i))$，其中$\mathrm{sel}(R_i)$表示表$R_i$上所有选择条件的选择度的乘积。

</font>

**$\sum_{j=1}^m\mathrm{I/O}_{\mathrm{join}}^{(j)}(R_j,S_j)$表示**

---
算了，直接参考GPT生成的结果吧，之后在例子中再具体进行计算

很好，你现在已经具备了查询优化代价计算的基础，我们现在进一步推广到**多表（n张表）连接 + 多维限制（多个选择条件）+ 多种算子（连接类型）**的一般情形，并总结**更加一般化的代价计算公式**。

---

#### ✅ 场景设定（一般形式）

假设有：

* $n$ 张关系表：$R_1, R_2, \dots, R_n$
* 每张表的元组数为 $T(R_i)$
* 每个表可能有多个选择条件：$\sigma_{p_{i1}}, \sigma_{p_{i2}}, \dots$
* 总共有 $m$ 个选择条件 $\{p_1, p_2, \dots, p_m\}$，每个选择条件 $p_j$ 有对应的选择度 $\text{sel}(p_j) \in (0,1]$
* 有 $k$ 个连接操作（Join），每个连接操作使用特定连接算子（如嵌套循环、哈希连接、排序归并等）
* 查询涉及投影（π）、排序（order by）、聚合（group by）、去重（distinct）等额外算子

---

#### 📐 定义符号（通用表示）

| 符号                        | 含义                               |
| ------------------------- | -------------------------------- |
| $T(R)$                    | 表 $R$ 的记录数（元组数）                  |
| $\text{sel}(p_j)$         | 谓词 $p_j$ 的选择度                    |
| $T(\sigma_{p_j}(R))$      | 应用选择条件后的中间结果基数                   |
| $J_i$                     | 第 $i$ 个连接操作                      |
| $\text{Cost}_X$           | 操作 $X$ 的代价，可以是 I/O, CPU 或 Memory |
| $\text{Join}_i(R_a, R_b)$ | 第 $i$ 个连接，连接关系 $R_a$ 和 $R_b$     |
| $\text{sel}_{J_i}$        | 第 $i$ 个连接的连接选择度                  |

---

#### ✅ 一般形式的代价计算公式（按代价类型分类）

---

#### ① **磁盘 I/O 代价（Disk I/O Cost）**

磁盘 I/O 主要包括：

* **扫描代价**
* **选择代价**
* **连接代价**
* **排序/聚合代价**

**通用公式：**

$$
\text{I/O}_{\text{total}} = \sum_{i=1}^n \text{I/O}_{\text{scan}}(R_i) + \sum_{j=1}^m \text{I/O}_{\text{select}}(p_j) + \sum_{l=1}^k \text{I/O}_{\text{join}}(J_l) + \text{I/O}_{\text{extra}}
$$

* $\text{I/O}_{\text{scan}}(R_i) = T(R_i)$
* $\text{I/O}_{\text{select}}(p_j) = \text{sel}(p_j) \cdot T(R_i)$
* $\text{I/O}_{\text{join}}$：根据连接算法决定：

  * **嵌套循环连接**：

    $$
    \text{I/O}_{\text{join}}(R, S) = T(R) \cdot T(S)
    $$
  * **哈希连接**：

    $$
    \text{I/O}_{\text{hash join}}(R, S) = T(R) + T(S)
    $$
  * **排序归并连接**（简化估计）：

    $$
    \text{I/O}_{\text{merge join}}(R, S) = T(R) \log T(R) + T(S) \log T(S)
    $$
* $\text{I/O}_{\text{extra}}$：包括排序、去重、聚合等操作

---

##### ② **CPU代价（CPU Cost）**

CPU代价包括：

* 谓词判断（选择）
* 连接比较
* 哈希函数计算（如果有）
* 排序/聚合的计算

**通用公式：**

$$
\text{CPU}_{\text{total}} = \sum_{j=1}^m T(\sigma_{p_j}(R)) + \sum_{l=1}^k \text{CPU}_{\text{join}}(J_l) + \text{CPU}_{\text{extra}}
$$

其中：

* $T(\sigma_{p_j}(R)) = \text{sel}(p_j) \cdot T(R)$
* $\text{CPU}_{\text{join}}$ 取决于连接算子：

  * 嵌套循环连接：$T(R) \cdot T(S)$
  * 哈希连接：$T(R) + T(S)$
* $\text{CPU}_{\text{extra}}$：包括排序、group by 的计算次数，取决于数据分布

---

##### ③ **内存代价（Memory Cost）**

内存代价主要指：

* 缓冲区占用
* 哈希表大小
* 中间结果存储

**通用公式：**

$$
\text{Mem}_{\text{total}} = \sum_{i=1}^n \text{Mem}_{\text{scan}}(R_i) + \sum_{l=1}^k \text{Mem}_{\text{join}}(J_l) + \text{Mem}_{\text{extra}}
$$

* 若一个表或中间结果放入内存，则：

  $$
  \text{Mem}_{\text{scan}}(R_i) = T(R_i)
  $$
* 对哈希连接：

  $$
  \text{Mem}_{\text{join}}(R, S) = \max(T(R), T(S)) \quad \text{（哈希表通常存放小表）}
  $$

---

#### ✅ 组合总结：总代价的统一表达式

如果我们统一用 $\text{Cost}_X$ 表示某类代价，则最终总代价可以统一为如下形式：

$$
\text{Cost}_{\text{total}} = \sum_{i=1}^n \text{Cost}_{\text{scan}}(R_i) + \sum_{j=1}^m \text{Cost}_{\text{select}}(p_j) + \sum_{l=1}^k \text{Cost}_{\text{join}}(J_l) + \text{Cost}_{\text{extra}}
$$

其中：

* $\text{Cost}_{\text{scan}}(R_i) = T(R_i)$
* $\text{Cost}_{\text{select}}(p_j) = \text{sel}(p_j) \cdot T(R_i)$
* $\text{Cost}_{\text{join}}(J_l)$ 取决于连接算法
* $\text{Cost}_{\text{extra}}$ 取决于是否有排序、聚合等操作

---

#### ✅ 小结（一句话理解）

你可以理解为：

> **查询总代价 = 各表扫描 + 筛选 + 各连接 + 额外操作** 的代价总和，每一部分都可以按表的大小、选择度、连接方式等用数学公式进行估算。

如果你想，我可以帮你写一个 Python 程序，输入这些参数，自动估算这三种代价。也可以帮你把公式做成图表，方便记忆。要试试吗？



































# 优化计算（slide11）






## 逻辑优化
在搞清楚代价之后，我们就可以来进行优化操作了，优化的方向是降低代价。
**逻辑优化降低的是IOcost和CPU cost。**
具体做法有如下三个操作：
1，选择下推
2，投影下推
3，查询重写
举例：
```sql
SELECT Sno, Sname, Grade
FROM SC, Student
WHERE SC.Sno = Student.Sno AND Cno = '1';
```
这个代码表示






## 物理优化





## AI优化






















