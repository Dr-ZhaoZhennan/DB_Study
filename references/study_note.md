# 第十章：查询处理
首先，这篇文章的核心就在于：**解析，优化，查询**。
## 解析
解析指的是将SQL语句解析成不同的步骤，接下来会去挨个执行不同的步骤。解析一共有三个解析过程，分别为：**词法分析，语法分析，语义分析**。
接下来，我们以一个例子来解释三个分析过程：
首先，我们通过SQL语句可以生成两张表格：
```sql
-- 创建Student表（学生表）
CREATE TABLE Student (
    Sno VARCHAR(10) PRIMARY KEY,  -- 学号，主键，长度为10的可变字符串
    Sname VARCHAR(20),            -- 学生姓名，长度为20的可变字符串
    Sgender VARCHAR(2),           -- 学生性别，长度为2的可变字符串（如"男"、"女"）
    Sage INT,                     -- 学生年龄，整型数据
    Sdept VARCHAR(20)             -- 学生所属系，长度为20的可变字符串（如"CS"表示计算机系）
);

-- 创建SC表（学生选课表）
CREATE TABLE SC (
    Sno VARCHAR(10),              -- 学号，外键，对应Student表的Sno
    Cno VARCHAR(10),              -- 课程号，长度为10的可变字符串
    Grade INT,                    -- 成绩，整型数据
    PRIMARY KEY (Sno, Cno)        -- 联合主键，由学号和课程号组成
);

-- 插入学生数据
INSERT INTO Student (Sno, Sname, Sgender, Sage, Sdept) VALUES
('2021310721', '李博', '男', 17, 'CS'),  -- 计算机系学生李博
('2021310722', '赵宇', '男', 19, 'CS'),  -- 计算机系学生赵宇
('2021310723', '王倩', '女', 18, 'MA'),  -- 数学系学生王倩
('2021310724', '孙悦', '女', 20, 'IS');  -- 信息系学生孙悦

-- 插入选课及成绩数据
INSERT INTO SC (Sno, Cno, Grade) VALUES
('2021310721', '5', 98),  -- 李博选修5号课程，成绩98分
('2021310722', '1', 87),  -- 赵宇选修1号课程，成绩87分
('2021310723', '1', 92),  -- 王倩选修1号课程，成绩92分
('2021310721', '1', 85);  -- 李博选修1号课程，成绩85分
```
运行语句：
```sql
SELECT S.Sname, SC.Grade   -- 选择学生姓名和成绩两个字段
FROM   Student AS S        -- 从Student表（别名为S）中查询
    JOIN SC ON S.Sno = SC.Sno  -- 与SC表进行内连接，连接条件是学号相同，join表示内连接。
WHERE  S.Sdept = 'CS'      -- 筛选条件1：只选计算机系(CS)学生
    AND SC.Grade >= 90; -- 筛选条件2：只选成绩大于等于90分的记录
```

```
如果有三张或者三张以上的表格，join的用法如下：
SELECT S.Sname, C.Cname, SC.Grade
FROM Student AS S
JOIN SC ON S.Sno = SC.Sno
JOIN Course AS C ON SC.Cno = C.Cno
WHERE S.Sdept = 'CS' AND SC.Grade >= 90;
这样一层层连接起来，就可以将表格进行内联。
FROM A
JOIN B ON 条件1
JOIN C ON 条件2
JOIN D ON 条件3
...
在很多张表格组合起来之后，每一张表格的主键也可以连接起来，成为逻辑主键


```

### 词法分析
方法：按照SQL词法将文本拆成token并且标注类别：**关键词、标识符、常量、运算符，分隔符，注释**
在上述代码中，我们可以将SQL语句进行处理，得到所有最小，有明确标识的记号（token）。六大类型分别有如下保留字：
#### 1，关键字（SQL本身自带的字）：
```sql
SELECT, FROM, WHERE, JOIN, ON, AS, GROUP, BY, ORDER, HAVING,
INSERT, INTO, VALUES, UPDATE, SET, DELETE,
CREATE, TABLE, PRIMARY, KEY, FOREIGN, NOT, NULL, AND, OR, IN, IS, LIKE, DISTINCT, EXISTS
```


#### 2，标识符（用户定义的名字，用来标识表、列、别名、数据库、索引等对象）：
```sql
在本表格中，标识符为：
Student, SC，Sno, Sname, Sgender, Sage, Sdept，Cno, Grade
```
这些字段都是用户进行定义的。

#### 3，常量（用户写在表格中的内容，也就是表格中的具体值）：
```sql
在本代码中，以下内容都是常量：
INSERT INTO Student (Sno, Sname, Sgender, Sage, Sdept) VALUES
('2021310721', '李博', '男', 17, 'CS'),  -- 常量：学号、姓名、性别、年龄、系别
('2021310722', '赵宇', '男', 19, 'CS'),  -- 常量：学号、姓名、性别、年龄、系别
('2021310723', '王倩', '女', 18, 'MA'),  -- 常量：学号、姓名、性别、年龄、系别
('2021310724', '孙悦', '女', 20, 'IS');  -- 常量：学号、姓名、性别、年龄、系别
```

#### 4，运算符（用于表达计算，条件，连接等操作的符号）
```sql
系统决定：
=, <>, <, <=, >, >=,
+, -, *, /,
AND, OR, NOT,
LIKE, IN, IS, BETWEEN
```

#### 5，分隔符（分割字段和语句）：
```sql
,    -- 逗号：用于分隔列名或值
;    -- 分号：结束一条 SQL 语句
( )  -- 括号：用于分组、函数参数、子查询
.    -- 点号：表.列 的限定
```


#### 6，注释（就是简单的注释）：
```sql
单行注释：-- 注释内容
多行注释：/* 注释内容 */
```
词法分析就可以将上述六个内容识别出来，例如在上述代码中，可以拆解成为：
```sql
-- 词法分析结果
[关键词]     SELECT
[标识符]     S.Sname
[符号]       ,
[标识符]     SC.Grade
[关键词]     FROM
[标识符]     Student
[关键词]     AS
[标识符]     S
[关键词]     JOIN
[标识符]     SC
[关键词]     ON
[标识符]     S.Sno
[符号]       =
[标识符]     SC.Sno
[关键词]     WHERE
[标识符]     S.Sdept
[符号]       =
[常量]       'CS'
[关键词]     AND
[标识符]     SC.Grade
[符号]       >=
[常量]       90
[符号]       ;

-- 注释（非执行部分）
[注释]       -- 选择学生姓名和成绩两个字段
[注释]       -- 从Student表（别名为S）中查询
[注释]       -- 与SC表进行内连接，连接条件是学号相同
[注释]       -- 筛选条件1：只选计算机系(CS)学生
[注释]       -- 筛选条件2：只选成绩大于等于90分的记录

-- 空白符（省略显示，存在于词法单位之间）
```
### 语法分析
语法分析相当于将拆分出来的不同的词串装组成抽象语法树：
首先先拆分字符：
```sql
[SELECT], [ID:S.Sname], [,], [ID:SC.Grade],
[FROM], [ID:Student], [AS], [ID:S],
[JOIN], [ID:SC], [ON], [ID:S.Sno], [=], [ID:SC.Sno],
[WHERE], [ID:S.Sdept], [=], [STR:'CS'],
[AND], [ID:SC.Grade], [>=], [NUM:90]
```
然后串起来构成语法树：
```
<query>
├── SELECT
│   └── <select_list>
│       ├── S.Sname
│       └── SC.Grade
├── FROM
│   └── <table_expr>
│       ├── <table_ref>
│       │   ├── Student
│       │   └── AS S
│       ├── JOIN
│       ├── <table_ref>
│       │   └── SC
│       └── ON
│           └── <condition>
│               └── S.Sno = SC.Sno
└── WHERE
    └── <condition>
        ├── S.Sdept = 'CS'
        └── AND
        └── SC.Grade >= 90

```


上述代码表示两个表格的拼接，可以用一个连接算子来表示：

**Student ⨝_{Sno} SC（表示二者相连接）**
```sql
+-------------+--------+---------+------+--------+-----+-------+
| Sno         | Sname  | Sgender | Sage | Sdept  | Cno | Grade |
+-------------+--------+---------+------+--------+-----+-------+
| 2021310721  | 李博   | 男      | 17   | CS     | 5   | 98    |
| 2021310721  | 李博   | 男      | 17   | CS     | 1   | 85    |
| 2021310722  | 赵宇   | 男      | 19   | CS     | 1   | 87    |
| 2021310723  | 王倩   | 女      | 18   | MA     | 1   | 92    |
+-------------+--------+---------+------+--------+-----+-------+
```
**注意：连接算子满足交换律和结合律，也满足选择分配律和投影分配律。**
至此，我们就学习了第一个算子：连接算子⨝。
### 语义分析
通俗来讲，就是上文所说的，将其进行连接：
```sql
-- 语义分析成功后的关系代数查询树表示：
π_{Sname, Grade}  
  σ_{Sdept = 'CS' ∧ Grade ≥ 90}  
    ⨝_{Student.Sno = SC.Sno}  
      Student  
      SC

```
这样，我们就可以将数据库进行一个初步的整理，目的是得到了一个可以运行的查询树，可以理解成一个粗整理。

顺其自然的，我们就得了解这些相关的算子，有哪些算子呢？

### 所有算子：
| 类别       | 算子        | 说明                                                     |
|------------|-------------|----------------------------------------------------------|
| 投影       | π（pi）      | 从结果中选取指定属性列                                  |
| 选择       | σ（sigma）   | 按条件筛选元组，如 σ_{Grade ≥ 90}(SC)                    |
| 连接       | ⨝（join）    | 将多个关系按条件组合，如 R ⨝_{A=B} S                    |
| 自然连接   | ⨝（自然连接）| 自动按同名属性连接                                       |
| 笛卡尔积   | ×           | 所有元组组合，常用于无连接条件情况                       |
| 并         | ∪           | 合并两个关系中的所有元组                                 |
| 差         | −           | 两个关系中属于第一个但不属于第二个的元组                 |
| 交         | ∩           | 两个关系中都包含的元组                                   |
| 去重       | δ（delta）   | 消除重复元组                                             |
| 分组聚集   | γ（gamma）   | GROUP BY + 聚集函数（SUM、AVG 等）                       |
| 排序算子   | Sort        | 外部归并排序，代价为 2 * ⌈log_{M-1}(B/M)⌉               |
| 选择算子   | IndexScan   | 用索引定位元组，聚簇与非聚簇的代价不同                   |
|            | TableScan   | 全表扫描                                                 |
| 连接算子   | NLJ         | 嵌套循环连接（Nested Loop Join）                        |
|            | BNLJ        | 块嵌套循环连接（Block Nested Loop Join）                 |
|            | INLJ        | 索引嵌套循环连接（Index Nested Loop Join）               |
|            | SMJ         | 排序-归并连接（Sort-Merge Join）                         |
|            | HashJoin    | 哈希连接，构建哈希表后进行匹配                           |
| 去重/集合  | Sort/Hash   | 基于排序或哈希实现集合运算（∪ ∩ −）和去重（δ）           |


算子顺序：

| 步骤 | 对应算子             | 说明                      |
| -- | ---------------- | ----------------------- |
| ①  | **FROM / JOIN**  | 连接各个表，形成临时笛卡尔积或连接结果     |
| ②  | **WHERE**        | 对上述结果做选择（σ），剔除不满足条件的行   |
| ③  | **GROUP BY**     | 对剩下的行分组，逻辑上进入 γ（分组聚合）算子 |
| ④  | **HAVING**       | 对每组做筛选，类似 GROUP 之后的 σ   |
| ⑤  | **SELECT**       | 投影（π），提取所需字段和聚合结果       |
| ⑥  | **DISTINCT**（可选） | 去重（δ），如 SELECT DISTINCT |
| ⑦  | **ORDER BY**     | 排序（Sort）                |

算子优先级：

| 优先级 | 算子类别     | 说明                          |
| --- | -------- | --------------------------- |
| 高   | 选择（σ）    | 越早筛掉不必要的行越节省计算资源            |
| 高   | 投影（π）    | 只保留需要的列，也有助于减少后续 I/O        |
| 中   | 连接（⨝）    | 是组合多个表的核心操作，代价较高，顺序优化很关键    |
| 中   | 分组聚合（γ）  | 只有在投影和连接之后才有意义              |
| 中   | 去重（δ）    | 通常是 SELECT DISTINCT 或集合运算触发 |
| 低   | 排序（Sort） | 排序通常最后执行，对结果进行排列            |

上述语句用算子表示可以表示成如下形式：
$$
\pi_{Sname,Grade} \left( (\sigma_{Sdept='CS'}(Student)) \underset{Student.Sno=SC.Sno}{\bowtie} (\sigma_{Grade \ge 90}(SC)) \right)
$$
*所以，如果定义计算这个函数的时间最短，即为优化函数。（这啥屁话）*
## 逻辑优化与物理优化
在学习这部分内容之前，先将这两个表格进行可视化操作：
**Student表（学生表）**
| Sno        | Sname | Sgender | Sage | Sdept |
| :--------- | :---- | :------ | :--- | :---- |
| 2021310721 | 李博  | 男      | 17   | CS    |
| 2021310722 | 赵宇  | 男      | 19   | CS    |
| 2021310723 | 王倩  | 女      | 18   | MA    |
| 2021310724 | 孙悦  | 女      | 20   | IS    |

**SC表（学生选课表）**
| Sno        | Cno | Grade |
| :--------- | :-- | :---- |
| 2021310721 | 5   | 98    |
| 2021310722 | 1   | 87    |
| 2021310723 | 1   | 92    |
| 2021310721 | 1   | 85    |



















